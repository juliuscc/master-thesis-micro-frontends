\chapter{Related work}


\section{Micro Frontends}
Micro frontends is a front end technique that originates from microservices \cite{Jackson2019}. Where microservices aim to solve scalability problems problems in the back-end, micro frontends aim to solve the same problems in the front-end, by applying many of the same concepts and methods. There does not exist one single definition but one of the introducers of micro frontends, ThoughtWorks, define microfrontends as:
\blockquote{An architectural style where independently deliverable frontend applications are composed into a greater whole \cite{Jackson2019}}

An important common aspect is the possibility for independent deployability \cite{Jackson2019}, where teams can deploy any changes to software owned by them, without affecting other teams. The way this is achieved is by using vertical slicing \cite[ch.~1]{Geers2020}, a software decomposition strategy based on composing software in functionally coherent slices that fully implement features \cite{Ratner2011}. This is opposite to horizontal slicing, where software is composed of modules that fulfill the same technological purpose like database-, entity-, controller-, boundary-layer \cite{Ratner2011}. The evolution of decomposition strategies are presented in Figure \ref{fig:vertical-slicing}. Some of the promised benefits from using micro frontends are: simple decoupled codebases, independent deployment, autonomous teams \cite{Jackson2019}, and greater customer focus \cite[ch.~1]{Geers2020}. 

There are many different integration approaches for bundling the final front end into a combined entity. The main categories are: 1) build-time integration, 2) server-side integration, and 3) client-side integration \cite{Jackson2019, Geers2020}. There is also route based integration or loosely coupled micro frontends where the front end consists of separate web pages served on different routes, that are connected using only hyperlinks \cites[ch.~2]{Geers2020}{Yang2019}. Build-time integration does not fit all definitions of micro frontends \cite{Geers2020} and there exists a consensus that using build-time integration looses many of the benefits of using micro frontends \cite{Jackson2019}.

Server-side integration is when a front end is split into fragments, which are combined in run-time \cite{Jackson2019, Geers2020}. This can be done by using Server Side Includes \cite{Geers2020,Jackson2019,Fagan}. A drawback with using server-side integration is that it does not enable dynamic client interactions. \cite[ch.~4]{Geers2020}. Dynamic in this case refers to the client application being able to update the graphical user interface, based on user interactions, without a page reload.

Client-side integration techniques are the most discussed micro frontends techniques, as many modern web pages require dynamic application design. Client-side integration techniques can be categorised into categories like: iframes \cites{Jackson2019}[ch.~2]{Geers2020}, web components \cites{Jackson2019}[ch.~5]{Geers2020}, and meta frameworks (also know as unified single page applications) \cite[ch.~6]{Geers2020}.


\section{Client-Side Integration Techniques}

The most naive integration method is using iframes which is a web native standard \cites{Jackson2019}[ch.~2]{Geers2020}. Using iframes are in essence using a micro frontend architecture, and they were officially introduced with the HTML 4.01 standard in 1998 \cite{Raggett1999}. Iframes comes with some negative trade-offs like performance overhead, accessibility problems, search engine optimization problems, and the lack of layout control \cite[ch.~2]{Geers2020}.

A more modern alternative to iframes are web components that is a new collection of web native standards \cite{MDNWebDocs}. They include APIs that allow custom elements to be defined and shadow DOM which is an API for encapsulating elements \cite{MDNWebDocs}. Shadow DOM allows styling and other properties to be scoped to a specific part of a web page, to limit interference between different components \cite{WebComponents.org}. It is not necessary to use custom elements together with shadow DOM, and the appropriate combination can be applied depending on the use case \cite{Geers2020}.

Web components are a low level construct, and therefore many frameworks exist that uses web components as a compilation target. Polymer is a large framework suite, that can be used to create web components \cite{ThePolymerProject,ThePolymerProjecta}. Polymer is developed by Google \cite{ThePolymerProjectb} and used in Google products like Youtube and Google Earth \cite{ThePolymerProjectc}. SkateJS \cite{SkateJS}, Slim.js \cite{Slim.js,Slim.jsa}, hybrids \cite{Lubanski}, and snuggsi \cite{DevPunks} are other light weight web component frameworks. Stensil is a web component tool set that allows applications written in the traditional frameworks Angular, React, Vue, Ember to become web components \cite{StencilJS}. Angular \cite{Googlec} and Vue \cite{Vuejs} has native support for creating web components.

Web components are supported in all major browsers: Edge, Firefox, Safari, Chrome and Opera \cite{WebComponents.orga}. There are fewer drawback with using web components compared with using iframes, but some still exist. The largest issue is that web components don't support progressive enhancement, which is when the front end is prerendered on the server before being served \cite[ch.~5]{Geers2020}. This can become a problem for performance, accessibility and search engine optimization. Another drawback, compared with using compilation-time integration is the lack of static annotations and analysis. Web components can be internally statically analysed but there does not exist any mechanism to share static annotations across the boundary of a web component.

There exists micro frontend frameworks that do not utilize web components like react-async-component \cite{Matheson}. One of the most popular and extensive frameworks is single-spa \cite{Single-spa}. It is a shell application that includes other application written in other frameworks \cite{Single-spa}. This kind of framework is called a unified single-page app, as it wraps other single-page-applications into one cohesive application \cite{Geers2020}. Single-spa requires that the root application be written as a single-spa application, which implies a large migration cost to existing applications \cite{Single-spa}. No micro frontend frameworks provide static analysis between the application boundaries.

